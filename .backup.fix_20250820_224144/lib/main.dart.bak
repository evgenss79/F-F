import 'dart:io';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';

import 'package:file_picker/file_picker.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

import 'data/local_store.dart';
import 'data/profile_store.dart';
import 'services/notify.dart';

import 'package:flutter_app_badger/flutter_app_badger.dart';
import 'package:badges/badges.dart' as badges;

class AppNotification {
  final String message;
  final DateTime time;
  bool read;

  AppNotification({
    required this.message,
    required this.time,
    this.read = false,
  });
}

class NotificationService {
  static final List<AppNotification> _notifications = [];

  static List<AppNotification> get notifications => _notifications;

  static void addNotification(String message) {
    _notifications.insert(
      0,
      AppNotification(message: message, time: DateTime.now()),
    );

    // обновляем бейдж на иконке приложения
    FlutterAppBadger.updateBadgeCount(unreadCount);
  }

  static void markAllRead() {
    for (var n in _notifications) {
      n.read = true;
    }
    FlutterAppBadger.removeBadge();
  }

  static int get unreadCount =>
      _notifications.where((n) => !n.read).length;
}


/// ============================ main() ============================
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Notify.init();
  await Notify.requestPermissions();
  runApp(const FamilyApp());
}

/// ============================ App ===============================
class FamilyApp extends StatelessWidget {
  const FamilyApp({super.key});

  @override
  Widget build(BuildContext context) {
    final light = ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFFFF6F61),
        brightness: Brightness.light,
      ),
      textTheme: GoogleFonts.nunitoTextTheme(),
    );

    final dark = ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFFFF6F61),
        brightness: Brightness.dark,
      ),
      textTheme: GoogleFonts.nunitoTextTheme(
        ThemeData(brightness: Brightness.dark).textTheme,
      ),
    );

    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'FamilySpace',
      theme: light,
      darkTheme: dark,
      home: const HomeShell(),
    );
  }
}

class HomeShell extends StatefulWidget {
  const HomeShell({super.key});
  @override
  State<HomeShell> createState() => _HomeShellState();
}

class _HomeShellState extends State<HomeShell> {
  int _index = 0;

  final _pages = const [
    ChatScreen(),
    TasksScreen(),
    AlbumsScreen(),
    ProfileScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: AnimatedSwitcher(
        duration: const Duration(milliseconds: 200),
        child: _pages[_index],
      ),
      bottomNavigationBar: NavigationBar(
        selectedIndex: _index,
        onDestinationSelected: (i) => setState(() => _index = i),
        destinations: const [
          NavigationDestination(icon: Icon(Icons.forum_outlined), label: 'Чат'),
          NavigationDestination(icon: Icon(Icons.check_circle_outlined), label: 'Задачи'),
          NavigationDestination(icon: Icon(Icons.photo_album_outlined), label: 'Альбомы'),
          NavigationDestination(icon: Icon(Icons.person_outline), label: 'Профиль'),
        ],
      ),
    );
  }
}

/// ============================ Чат (заглушка) ====================
class ChatScreen extends StatelessWidget {
  const ChatScreen({super.key});
  @override
  Widget build(BuildContext context) {
    return const _PageTemplate(
      title: 'Семейный чат',
      subtitle: 'Здесь будет общение семьи',
      icon: Icons.forum_outlined,
    );
  }
}

/// ============================ Задачи ============================
class TasksScreen extends StatefulWidget {
  const TasksScreen({super.key});
  @override
  State<TasksScreen> createState() => _TasksScreenState();
}

class _TasksScreenState extends State<TasksScreen> {
  final _store = LocalStore();
  List<TaskItem> _tasks = [];
  bool _loading = true;
  String _currentUserName = 'Я';

  @override
  void initState() {
    super.initState();
    _loadAll();
  }

  Future<void> _loadAll() async {
    try {
      final p = await ProfileStore().load();
      if ((p.name ?? '').trim().isNotEmpty) {
        _currentUserName = p.name!.trim();
      }
    } catch (_) {}
    final list = await _store.loadTasks();
    setState(() {
      _tasks = list;
      _loading = false;
    });
  }

  Future<void> _save() async => _store.saveTasks(_tasks);

  Future<void> _onStatusChanged(TaskItem t, bool newValue) async {
    final wasDone = t.done;
    setState(() {
      _tasks =
          _tasks.map((e) => e.id == t.id ? e.copyWith(done: newValue) : e).toList();
    });
    await _save();

    if (!wasDone && newValue) {
      if (t.assignedTo == null) {
        await Notify.show('Общая задача выполнена', '«${t.title}» выполнена.');
      } else {
        await Notify.show('Задача выполнена',
            'Исполнитель: ${t.assignedTo}\nНазначил: ${t.assignedBy}\n«${t.title}»');
      }
    }
  }

  Future<void> _delete(TaskItem t) async {
    if (_currentUserName != t.assignedBy) {
      await showDialog(
        context: context,
        builder: (_) => const AlertDialog(
          title: Text('Удаление запрещено'),
          content: Text('Удалить задачу может только тот, кто её назначил.'),
        ),
      );
      return;
    }
    final ok = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Удалить задачу?'),
        content: Text(t.title),
        actions: [
          TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: const Text('Отмена')),
          FilledButton(
              onPressed: () => Navigator.pop(context, true),
              child: const Text('Удалить')),
        ],
      ),
    );
    if (ok != true) return;

    setState(() {
      _tasks = _tasks.where((e) => e.id != t.id).toList();
    });
    await _save();
  }

  Future<void> _addOrEdit({TaskItem? edit}) async {
    final result = await showModalBottomSheet<TaskItem>(
      context: context,
      isScrollControlled: true,
      builder: (ctx) => Padding(
        padding: EdgeInsets.only(bottom: MediaQuery.of(ctx).viewInsets.bottom),
        child: _TaskEditor(currentUserName: _currentUserName, initial: edit),
      ),
    );
    if (result == null) return;

    setState(() {
      if (edit == null) {
        _tasks = [..._tasks, result];
      } else {
        _tasks = _tasks.map((e) => e.id == edit.id ? result : e).toList();
      }
    });
    await _save();

    if (edit == null) {
      if (result.assignedTo == null) {
        await Notify.show(
          'Новая общая задача',
          'Назначил: ${result.assignedBy}\n«${result.title}»'
          '${result.deadline != null ? '\nСрок: ${_fmt(result.deadline!)}' : ''}',
        );
      } else {
        await Notify.show(
          'Новая задача для ${result.assignedTo}',
          'Назначил: ${result.assignedBy}\n«${result.title}»'
          '${result.deadline != null ? '\nСрок: ${_fmt(result.deadline!)}' : ''}',
        );
      }
    } else {
      await Notify.show(
        'Задача обновлена',
        '«${result.title}»\nНазначил: ${result.assignedBy}'
        '${result.assignedTo != null ? '\nИсполнитель: ${result.assignedTo}' : ''}',
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final common = _tasks.where((t) => t.assignedTo == null).toList()
      ..sort((a, b) => _sortByDeadlineThenCreated(a, b));
    final individual = _tasks.where((t) => t.assignedTo != null).toList()
      ..sort((a, b) => _sortByDeadlineThenCreated(a, b));

    return Scaffold(
      appBar: AppBar(
        title: const Text('Задачи семьи'),
        actions: [
          IconButton(
            tooltip: 'Тест уведомления',
            icon: const Icon(Icons.notifications_active_outlined),
            onPressed: () {
              Notify.show('Тест от FamilySpace', 'Если видишь это — уведомления работают');
            },
          ),
        ],
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : ListView(
              children: [
                const _SectionHeader('Общие задачи'),
                if (common.isEmpty)
                  const _EmptyHint('Пока пусто. Добавьте общую задачу.'),
                ...common.map((t) => _TaskCard(
                      task: t,
                      canDelete: _currentUserName == t.assignedBy,
                      onToggle: (v) => _onStatusChanged(t, v),
                      onEdit: () => _addOrEdit(edit: t),
                      onDelete: () => _delete(t),
                    )),
                const _SectionHeader('Индивидуальные задачи'),
                if (individual.isEmpty)
                  const _EmptyHint('Здесь появятся задачи с назначенным исполнителем.'),
                ...individual.map((t) => _TaskCard(
                      task: t,
                      canDelete: _currentUserName == t.assignedBy,
                      onToggle: (v) => _onStatusChanged(t, v),
                      onEdit: () => _addOrEdit(edit: t),
                      onDelete: () => _delete(t),
                    )),
                const SizedBox(height: 88),
              ],
            ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _addOrEdit(),
        icon: const Icon(Icons.add),
        label: const Text('Новая задача'),
      ),
    );
  }

  int _sortByDeadlineThenCreated(TaskItem a, TaskItem b) {
    final ad = a.deadline;
    final bd = b.deadline;
    if (ad != null && bd != null) {
      final cmp = ad.compareTo(bd);
      if (cmp != 0) return cmp;
    } else if (ad != null && bd == null) {
      return -1;
    } else if (ad == null && bd != null) {
      return 1;
    }
    return a.createdAt.compareTo(b.createdAt);
  }

  String _pad2(int v) => v < 10 ? '0$v' : '$v';
  String _fmt(DateTime dt) {
    final y = dt.year;
    final m = _pad2(dt.month);
    final d = _pad2(dt.day);
    final hh = _pad2(dt.hour);
    final mm = _pad2(dt.minute);
    return '$y-$m-$d $hh:$mm';
  }
}

class _TaskEditor extends StatefulWidget {
  final String currentUserName;
  final TaskItem? initial;
  const _TaskEditor({required this.currentUserName, this.initial});

  @override
  State<_TaskEditor> createState() => _TaskEditorState();
}

class _TaskEditorState extends State<_TaskEditor> {
  final _title = TextEditingController();
  final _desc = TextEditingController();
  final _assignee = TextEditingController();

  bool _isGeneral = true;
  DateTime? _deadline;

  @override
  void initState() {
    super.initState();
    final i = widget.initial;
    if (i != null) {
      _title.text = i.title;
      _desc.text = i.description;
      _assignee.text = i.assignedTo ?? '';
      _isGeneral = i.assignedTo == null;
      _deadline = i.deadline;
    }
  }

  @override
  void dispose() {
    _title.dispose();
    _desc.dispose();
    _assignee.dispose();
    super.dispose();
  }

  Future<void> _pickDeadline() async {
    final now = DateTime.now();
    final date = await showDatePicker(
      context: context,
      firstDate: DateTime(now.year - 1),
      lastDate: DateTime(now.year + 5),
      initialDate: _deadline ?? now,
    );
    if (date == null) return;
    final time = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(_deadline ?? now),
    );
    setState(() {
      _deadline = DateTime(
        date.year, date.month, date.day,
        time?.hour ?? 0, time?.minute ?? 0,
      );
    });
  }

  String _pad2(int v) => v < 10 ? '0$v' : '$v';
  String _fmt(DateTime dt) =>
      '${dt.year}-${_pad2(dt.month)}-${_pad2(dt.day)} ${_pad2(dt.hour)}:${_pad2(dt.minute)}';

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              height: 4,
              width: 40,
              margin: const EdgeInsets.only(bottom: 12),
              decoration: BoxDecoration(
                color: cs.outlineVariant,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            Text(
              widget.initial == null ? 'Новая задача' : 'Редактировать задачу',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _title,
              decoration: const InputDecoration(
                labelText: 'Название',
                hintText: 'Например: Купить молоко',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: _desc,
              maxLines: 2,
              decoration: const InputDecoration(
                labelText: 'Описание (необязательно)',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 8),
            SwitchListTile(
              title: const Text('Общая задача (без конкретного исполнителя)'),
              value: _isGeneral,
              onChanged: (v) => setState(() => _isGeneral = v),
            ),
            if (!_isGeneral) ...[
              const SizedBox(height: 8),
              TextField(
                controller: _assignee,
                decoration: const InputDecoration(
                  labelText: 'Исполнитель',
                  hintText: 'Имя члена семьи',
                  border: OutlineInputBorder(),
                ),
              ),
            ],
            const SizedBox(height: 8),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: _pickDeadline,
                    icon: const Icon(Icons.schedule),
                    label: Text(
                      _deadline == null ? 'Выбрать срок' : 'Срок: ${_fmt(_deadline!)}',
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: FilledButton.icon(
                    icon: const Icon(Icons.save_outlined),
                    label: const Text('Сохранить'),
                    onPressed: () {
                      final title = _title.text.trim();
                      if (title.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Введите название')),
                        );
                        return;
                      }
                      final id = widget.initial?.id ??
                          '${DateTime.now().millisecondsSinceEpoch}_${Random().nextInt(10000)}';
                      final item = TaskItem(
                        id: id,
                        title: title,
                        description: _desc.text.trim(),
                        done: widget.initial?.done ?? false,
                        assignedBy:
                            widget.initial?.assignedBy ?? widget.currentUserName,
                        assignedTo: _isGeneral
                            ? null
                            : (_assignee.text.trim().isEmpty
                                ? widget.currentUserName
                                : _assignee.text.trim()),
                        createdAt:
                            widget.initial?.createdAt ?? DateTime.now(),
                        deadline: _deadline,
                      );
                      Navigator.pop(context, item);
                    },
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  final String title;
  const _SectionHeader(this.title);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 20, 16, 8),
      child: Text(
        title,
        style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
      ),
    );
  }
}

class _EmptyHint extends StatelessWidget {
  final String text;
  const _EmptyHint(this.text);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
      child: Text(
        text,
        style: TextStyle(color: Theme.of(context).colorScheme.outline),
      ),
    );
  }
}

class _TaskCard extends StatelessWidget {
  final TaskItem task;
  final bool canDelete;
  final ValueChanged<bool> onToggle;
  final VoidCallback onEdit;
  final VoidCallback onDelete;

  const _TaskCard({
    super.key,
    required this.task,
    required this.canDelete,
    required this.onToggle,
    required this.onEdit,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Dismissible(
      key: ValueKey(task.id),
      direction: canDelete ? DismissDirection.endToStart : DismissDirection.none,
      background: Container(
        color: Colors.red,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.symmetric(horizontal: 16),
        child: const Icon(Icons.delete, color: Colors.white),
      ),
      confirmDismiss: (_) async {
        if (!canDelete) {
          await showDialog(
            context: context,
            builder: (_) => const AlertDialog(
              title: Text('Удаление запрещено'),
              content: Text('Удалить задачу может только тот, кто её назначил.'),
            ),
          );
          return false;
        }
        return true;
      },
      onDismissed: (_) => onDelete(),
      child: Card(
        margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8),
          child: ListTile(
            leading: Checkbox(
              value: task.done,
              onChanged: (v) => onToggle(v ?? false),
            ),
            title: Text(
              task.title,
              style: task.done
                  ? const TextStyle(
                      decoration: TextDecoration.lineThrough,
                      color: Colors.grey,
                    )
                  : null,
            ),
            subtitle: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (task.description.trim().isNotEmpty)
                  Text(task.description.trim()),
                const SizedBox(height: 4),
                Wrap(
                  spacing: 12,
                  runSpacing: 4,
                  children: [
                    _Chip(icon: Icons.event_note, label: 'Создано: ${_fmt(task.createdAt)}'),
                    if (task.deadline != null)
                      _Chip(
                        icon: Icons.schedule,
                        label: 'Срок: ${_fmt(task.deadline!)}',
                        color: (task.deadline!.isBefore(DateTime.now()) && !task.done)
                            ? Colors.red.withOpacity(0.1)
                            : null,
                      ),
                    _Chip(icon: Icons.person_add_alt, label: 'Назначил: ${task.assignedBy}'),
                    _Chip(
                      icon: Icons.assignment_ind_outlined,
                      label: task.assignedTo == null
                          ? 'Тип: общая'
                          : 'Исполнитель: ${task.assignedTo}',
                    ),
                  ],
                ),
              ],
            ),
            trailing: IconButton(
              tooltip: 'Редактировать',
              onPressed: onEdit,
              icon: Icon(Icons.edit_outlined, color: cs.primary),
            ),
          ),
        ),
      ),
    );
  }

  String _pad2(int v) => v < 10 ? '0$v' : '$v';
  String _fmt(DateTime dt) {
    final y = dt.year;
    final m = _pad2(dt.month);
    final d = _pad2(dt.day);
    final hh = _pad2(dt.hour);
    final mm = _pad2(dt.minute);
    return '$y-$m-$d $hh:$mm';
  }
}

class _Chip extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color? color;
  const _Chip({required this.icon, required this.label, this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
      decoration: BoxDecoration(
        color: color ?? Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(mainAxisSize: MainAxisSize.min, children: [
        Icon(icon, size: 14),
        const SizedBox(width: 6),
        Text(label),
      ]),
    );
  }
}

/// ============================ Альбомы (заглушка) =================
class AlbumsScreen extends StatelessWidget {
  const AlbumsScreen({super.key});
  @override
  Widget build(BuildContext context) {
    return const _PageTemplate(
      title: 'Семейные альбомы',
      subtitle: 'Фото и видео семьи',
      icon: Icons.photo_album_outlined,
    );
  }
}

/// ============================ Профиль ===========================
class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});
  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  final _store = ProfileStore();
  Profile _profile = const Profile();
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final p = await _store.load();
    setState(() {
      _profile = p;
      _loading = false;
    });
  }

  Future<void> _pickAvatar() async {
    try {
      String? savedPath;

      if (Platform.isMacOS) {
        // 1) Выбираем картинку через системный диалог
        final res = await FilePicker.platform.pickFiles(type: FileType.image);
        if (res == null || res.files.single.path == null) return;

        final srcPath = res.files.single.path!;
        // 2) Копируем в папку приложения (чтобы всегда был доступ)
        final appDir = await getApplicationSupportDirectory();
        final avatarsDir = Directory(p.join(appDir.path, 'avatars'));
        if (!await avatarsDir.exists()) {
          await avatarsDir.create(recursive: true);
        }
        final ext = p.extension(srcPath);
        final dst = p.join(
          avatarsDir.path,
          'avatar_${DateTime.now().millisecondsSinceEpoch}$ext',
        );
        await File(srcPath).copy(dst);
        savedPath = dst;
      } else {
        // iOS/Android — стандартный image_picker
        final x = await ImagePicker().pickImage(
          source: ImageSource.gallery,
          imageQuality: 85,
          maxWidth: 2000,
        );
        if (x == null) return;
        // На мобильных можно использовать путь напрямую
        savedPath = x.path;
      }

      final updated = _profile.copyWith(avatarPath: savedPath);
      await _store.save(updated);
      if (!mounted) return;
      setState(() => _profile = updated);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Аватар обновлён')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Не удалось загрузить фото: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(title: const Text('Профиль')),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : ListView(
              padding: const EdgeInsets.all(16),
              children: [
                Center(
                  child: Stack(
                    children: [
                      CircleAvatar(
                        radius: 48,
                        backgroundColor: cs.primaryContainer,
                        backgroundImage: (_profile.avatarPath != null &&
                                _profile.avatarPath!.isNotEmpty)
                            ? FileImage(File(_profile.avatarPath!))
                            : null,
                        child: (_profile.avatarPath == null ||
                                _profile.avatarPath!.isEmpty)
                            ? const Icon(Icons.person, size: 48)
                            : null,
                      ),
                      Positioned(
                        right: -6,
                        bottom: -6,
                        child: IconButton(
                          onPressed: _pickAvatar,
                          icon: const Icon(Icons.edit, size: 20),
                          style: IconButton.styleFrom(
                            backgroundColor: cs.surfaceContainerHighest,
                          ),
                          tooltip: 'Изменить аватар',
                        ),
                      )
                    ],
                  ),
                ),
                const SizedBox(height: 12),
                Center(
                  child: Text(
                    _profile.name?.isNotEmpty == true
                        ? _profile.name!
                        : 'Имя не указано',
                    style: Theme.of(context)
                        .textTheme
                        .titleLarge
                        ?.copyWith(fontWeight: FontWeight.bold),
                  ),
                ),
                const SizedBox(height: 16),
                FilledButton.icon(
                  onPressed: () async {
                    final changed = await Navigator.push<Profile>(
                      context,
                      MaterialPageRoute(
                        builder: (_) => EditProfileScreen(initial: _profile),
                      ),
                    );
                    if (changed != null) {
                      await _store.save(changed);
                      if (mounted) setState(() => _profile = changed);
                    }
                  },
                  icon: const Icon(Icons.edit),
                  label: const Text('Редактировать'),
                ),
              ],
            ),
    );
  }
}

/// Экран редактирования — поля сохраняются кнопкой «Сохранить»
class EditProfileScreen extends StatefulWidget {
  final Profile initial;
  const EditProfileScreen({super.key, required this.initial});
  @override
  State<EditProfileScreen> createState() => _EditProfileScreenState();
}

class _EditProfileScreenState extends State<EditProfileScreen> {
  final _form = GlobalKey<FormState>();
  final _name = TextEditingController();
  final _phone = TextEditingController();
  final _email = TextEditingController();
  final _instagram = TextEditingController();
  final _discord = TextEditingController();
  final _telegram = TextEditingController();
  final _otherSocial = TextEditingController();
  final _orgName = TextEditingController();
  final _orgAddress = TextEditingController();
  final _orgClassOrRole = TextEditingController();
  final _orgContactAddress = TextEditingController();
  final _orgContactPhone = TextEditingController();
  final _orgContactEmail = TextEditingController();
  final _bestFriends = TextEditingController();
  final _birthday = TextEditingController();
  final _interests = TextEditingController();
  final _lifeDream = TextEditingController();
  final _shortMidWishes = TextEditingController();

  String? _avatarPath;
  String? _extraPhotoPath;
  String _relation = 'сын';

  @override
  void initState() {
    super.initState();
    final p = widget.initial;
    _name.text = p.name ?? '';
    _phone.text = p.phone ?? '';
    _email.text = p.email ?? '';
    _instagram.text = p.instagram ?? '';
    _discord.text = p.discord ?? '';
    _telegram.text = p.telegram ?? '';
    _otherSocial.text = p.otherSocial ?? '';
    _orgName.text = p.orgName ?? '';
    _orgAddress.text = p.orgAddress ?? '';
    _orgClassOrRole.text = p.orgClassOrRole ?? '';
    _orgContactAddress.text = p.orgContactAddress ?? '';
    _orgContactPhone.text = p.orgContactPhone ?? '';
    _orgContactEmail.text = p.orgContactEmail ?? '';
    _bestFriends.text = p.bestFriends ?? '';
    _relation = p.relation ?? 'сын';
    _birthday.text = p.birthday ?? '';
    _interests.text = p.interests ?? '';
    _lifeDream.text = p.lifeDream ?? '';
    _shortMidWishes.text = p.shortMidWishes ?? '';
    _avatarPath = p.avatarPath;
    _extraPhotoPath = p.extraPhotoPath;
  }

  Future<void> _pickImage(bool isAvatar) async {
    try {
      String? savedPath;

      if (Platform.isMacOS) {
        final res = await FilePicker.platform.pickFiles(type: FileType.image);
        if (res == null || res.files.single.path == null) return;
        final srcPath = res.files.single.path!;
        final appDir = await getApplicationSupportDirectory();
        final dir = Directory(p.join(appDir.path, isAvatar ? 'avatars' : 'photos'));
        if (!await dir.exists()) await dir.create(recursive: true);
        final ext = p.extension(srcPath);
        final dst = p.join(
          dir.path,
          '${isAvatar ? 'avatar' : 'photo'}_${DateTime.now().millisecondsSinceEpoch}$ext',
        );
        await File(srcPath).copy(dst);
        savedPath = dst;
      } else {
        final x = await ImagePicker().pickImage(
          source: ImageSource.gallery,
          imageQuality: 85,
          maxWidth: 2000,
        );
        if (x == null) return;
        savedPath = x.path;
      }

      setState(() {
        if (isAvatar) {
          _avatarPath = savedPath;
        } else {
          _extraPhotoPath = savedPath;
        }
      });
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Не удалось выбрать фото: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(title: const Text('Редактирование профиля')),
      body: Form(
        key: _form,
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            Row(
              children: [
                Stack(
                  children: [
                    CircleAvatar(
                      radius: 36,
                      backgroundColor: cs.primaryContainer,
                      backgroundImage: (_avatarPath != null &&
                              _avatarPath!.isNotEmpty)
                          ? FileImage(File(_avatarPath!))
                          : null,
                      child: (_avatarPath == null || _avatarPath!.isEmpty)
                          ? const Icon(Icons.person, size: 36)
                          : null,
                    ),
                    Positioned(
                      right: -6,
                      bottom: -6,
                      child: IconButton(
                        onPressed: () => _pickImage(true),
                        icon: const Icon(Icons.edit, size: 20),
                        style: IconButton.styleFrom(
                          backgroundColor: cs.surfaceContainerHighest,
                        ),
                      ),
                    )
                  ],
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: TextFormField(
                    controller: _name,
                    decoration: const InputDecoration(labelText: 'Имя'),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),

            TextFormField(controller: _phone, decoration: const InputDecoration(labelText: 'Номер телефона')),
            const SizedBox(height: 8),
            TextFormField(controller: _email, decoration: const InputDecoration(labelText: 'E-mail')),

            const SizedBox(height: 12),
            Text('Профили в соцсетях', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            TextFormField(controller: _instagram, decoration: const InputDecoration(labelText: 'Instagram')),
            const SizedBox(height: 8),
            TextFormField(controller: _discord, decoration: const InputDecoration(labelText: 'Discord')),
            const SizedBox(height: 8),
            TextFormField(controller: _telegram, decoration: const InputDecoration(labelText: 'Telegram')),
            const SizedBox(height: 8),
            TextFormField(controller: _otherSocial, decoration: const InputDecoration(labelText: 'Другое')),

            const SizedBox(height: 12),
            Text('Учебное заведение / Работа', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            TextFormField(controller: _orgName, decoration: const InputDecoration(labelText: 'Название')),
            const SizedBox(height: 8),
            TextFormField(controller: _orgAddress, decoration: const InputDecoration(labelText: 'Адрес')),
            const SizedBox(height: 8),
            TextFormField(controller: _orgClassOrRole, decoration: const InputDecoration(labelText: 'Класс / Должность')),

            const SizedBox(height: 12),
            Text('Контакты учебного заведения / работодателя', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            TextFormField(controller: _orgContactAddress, decoration: const InputDecoration(labelText: 'Адрес')),
            const SizedBox(height: 8),
            TextFormField(controller: _orgContactPhone, decoration: const InputDecoration(labelText: 'Телефон')),
            const SizedBox(height: 8),
            TextFormField(controller: _orgContactEmail, decoration: const InputDecoration(labelText: 'E-mail')),

            const SizedBox(height: 12),
            TextFormField(
              controller: _bestFriends,
              decoration: const InputDecoration(
                labelText: 'Лучшие друзья и их контакты',
                hintText: 'Имя — телефон/email; по одному в строке',
              ),
              maxLines: 3,
            ),

            const SizedBox(height: 12),
            DropdownButtonFormField<String>(
              value: _relation,
              decoration: const InputDecoration(labelText: 'Родственная связь'),
              items: const [
                DropdownMenuItem(value: 'сын', child: Text('Сын')),
                DropdownMenuItem(value: 'дочь', child: Text('Дочь')),
                DropdownMenuItem(value: 'мама', child: Text('Мама')),
                DropdownMenuItem(value: 'папа', child: Text('Папа')),
                DropdownMenuItem(value: 'племянник', child: Text('Племянник')),
                DropdownMenuItem(value: 'племянница', child: Text('Племянница')),
                DropdownMenuItem(value: 'дедушка', child: Text('Дедушка')),
                DropdownMenuItem(value: 'бабушка', child: Text('Бабушка')),
                DropdownMenuItem(value: 'другое', child: Text('Другое')),
              ],
              onChanged: (v) => setState(() => _relation = v ?? 'сын'),
            ),

            const SizedBox(height: 8),
            TextFormField(
              controller: _birthday,
              decoration: const InputDecoration(labelText: 'Дата рождения (YYYY-MM-DD)'),
            ),

            const SizedBox(height: 12),
            TextFormField(controller: _interests, decoration: const InputDecoration(labelText: 'Интересы / хобби'), maxLines: 2),
            const SizedBox(height: 8),
            TextFormField(controller: _lifeDream, decoration: const InputDecoration(labelText: 'Мечта всей жизни'), maxLines: 2),
            const SizedBox(height: 8),
            TextFormField(controller: _shortMidWishes, decoration: const InputDecoration(labelText: 'Желания на 6–12 месяцев'), maxLines: 2),

            const SizedBox(height: 12),
            Text('Доп. фото', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            Row(
              children: [
                SizedBox(
                  width: 72,
                  height: 72,
                  child: (_extraPhotoPath != null && _extraPhotoPath!.isNotEmpty)
                      ? ClipRRect(
                          borderRadius: BorderRadius.circular(8),
                          child: Image.file(File(_extraPhotoPath!), fit: BoxFit.cover),
                        )
                      : Container(
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: cs.outline),
                          ),
                          child: const Icon(Icons.photo, size: 32),
                        ),
                ),
                const SizedBox(width: 12),
                OutlinedButton.icon(
                  onPressed: () => _pickImage(false),
                  icon: const Icon(Icons.add_a_photo_outlined),
                  label: const Text('Выбрать фото'),
                ),
              ],
            ),

            const SizedBox(height: 24),
            FilledButton.icon(
              onPressed: () async {
                final p = Profile(
                  name: _name.text.trim(),
                  avatarPath: _avatarPath,
                  phone: _phone.text.trim(),
                  email: _email.text.trim(),
                  instagram: _instagram.text.trim(),
                  discord: _discord.text.trim(),
                  telegram: _telegram.text.trim(),
                  otherSocial: _otherSocial.text.trim(),
                  orgName: _orgName.text.trim(),
                  orgAddress: _orgAddress.text.trim(),
                  orgClassOrRole: _orgClassOrRole.text.trim(),
                  orgContactAddress: _orgContactAddress.text.trim(),
                  orgContactPhone: _orgContactPhone.text.trim(),
                  orgContactEmail: _orgContactEmail.text.trim(),
                  bestFriends: _bestFriends.text.trim(),
                  relation: _relation,
                  birthday: _birthday.text.trim(),
                  interests: _interests.text.trim(),
                  lifeDream: _lifeDream.text.trim(),
                  shortMidWishes: _shortMidWishes.text.trim(),
                  extraPhotoPath: _extraPhotoPath,
                );
                await ProfileStore().save(p);
                if (mounted) Navigator.pop(context, p);
              },
              icon: const Icon(Icons.save_outlined),
              label: const Text('Сохранить'),
            ),
          ],
        ),
      ),
    );
  }
}

/// ============================ Общий шаблон страницы =============
class _PageTemplate extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  const _PageTemplate({
    required this.title,
    required this.subtitle,
    required this.icon,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(title: Text(title)),
      body: Center(
        child: Container(
          constraints: const BoxConstraints(maxWidth: 520),
          padding: const EdgeInsets.all(24),
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(mainAxisSize: MainAxisSize.min, children: [
                Icon(icon, size: 56, color: cs.primary),
                const SizedBox(height: 16),
                Text(
                  title,
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                Text(subtitle, textAlign: TextAlign.center),
              ]),
            ),
          ),
        ),
      ),
    );
  }
}
